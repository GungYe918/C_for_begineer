# 비트연산자에 대한 개념
### 1-1. 개념

컴퓨터 안에서 처리되는 모든 데이터들은 비트(bit)형태로 표현되고 저장된다. 
이때 비트연산자(bit operator)는 이 데이터들을 비트 단위로 연산한다. 
비트 연산자는 비트 논리 연산자와 비트 시프트 연산자로 구분되는데, 자세한 내용은 아래의 표와 같다.

<br>

#### <비트 논리 연산자>

|연산자|사용방법|의미|   
|----|-----|----|
|~|~a|a에 저장된 값에 대한 1의 보수|
|&|a&b|a에 저장된 값과, b에 저장된 값의 비트 단위의 논리곱|
|\||a \| b|a에 저장된 값과, b에 저장된 값의 비트 단위의 논리합|

처음 보는 단어가 3개나 등장한다. 
1. 이때 **보수**는 수학적인 개념이므로 [여기](https://ko.wikipedia.org/wiki/%EB%B3%B4%EC%88%98_(%EC%88%98%ED%95%99))를 참조하면 좋다.

2. **논리곱**은 (**AND**)라고도 하며, 주어진 두 조건이 모두 참인 경우에만 전체 식을 참으로 평가한다. 
	수학 집합에서의 교집합을 생각하면 이해가 쉬울 것이다.
	**논리곱**은 (**OR**)라고도 하며 **if문**의 AND, OR연산에도 사용되지만, 이번 비트 논리 연산에서는 두 수를 비트 단위로 비교한다.


다음은 **논리곱**을 사용하는 간단한 예시이다.

```c
0 & 0 -> 결과: 0
0 & 1 -> 결과: 0
1 & 0 -> 결과: 0
1 & 1 -> 결과: 1
```

<br>

3. **논리합**은 (**OR**)라고도 하며, 주어진 두 조건중 하나가 참인 경우 전체 식을 참으로 평가한다.
	수학 집합에서의 합집합과 대응되는 개념이라고 생각하면 이해가 쉬울 것이다.
	논라합은 논리곱과 마찬가지로 **if문**의 조건식에 사용되지만, 이번 비트 논리 연산에서는 두 수를 
	비트 단위로 비교하여 연산한다. 


다음은 논리합을 사용하는 간단한 예시이다.

```C
1 | 0 -> 결과: 1
0 | 1 -> 결과: 1
1 | 1 -> 결과: 1
0 | 0 -> 결과: 0
```

<br>

<br>

#### <비트 시프트 연산자>

|연산자|사용방법|의미|   
|----|-----|----|
|^|a^b|a의 값과 b의 값에 대한 베타적 논리합|
|<<|a<<b|a의 값을 b만큼 왼쪽으로 시프트 연산|
|>>|a>>b|a의 값을 b만큼 오른쪽으로 시프트 연산|

역시 모르는 단어가 3개 등장한다. 
1. **베타적 논리합** 역시 수학에서의 개념이므로 [여기](https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9)를 참조하는것이 도움이 될 것이다. 
	**베타적 논리함**은 (**XOR**)라고도 하며, 두 조건(여기서는 비트)이 서로 다른 경우에만 참(1)의 값을 가진다.
	벤 다이어그램으로 나타낼 경우 아래의 그림처럼 표현된다.

![[Pasted image 20230806163726.png]]

<br>

다음은 **베타적 논리합** 연산자를 사용하는 간단한 예시이다.

```C
0 ^ 0 -> 결과: 0
0 ^ 1 -> 결과: 1
1 ^ 0 -> 결과: 1
1 ^ 1 -> 결과: 0
```

<br>

2. 각 시프트 연산자(`>>`, `<<`)는 **2항 연산자**로써 정수를 어느 자릿수로 이동시킬지 결정하는
	연산자이기에 **부호 없는 정수형 데이터**(unsigned int)자료형을 사용한다.
	
	**<<**(오른쪽 시프트)연산자는 비트열을 오른쪽으로 이동하면서 왼쪽 비트를 모두 0으로 채운다.
	**>>**(왼쪽 시프트)연산자는 비트열을 왼쪽으로 이동하면서 오른쪽 비트를 모두 0으로 채운다.

다음은 각 비트 시프트 연산을 그림으로 표현한 것이다.

##### <왼쪽 비트시프트 연산의 경우>
![[Pasted image 20230806164759.png]]
<br>

##### <오른쪽 비트시프트 연산의 경우> ![[Pasted image 20230806164917.png]]
<br>

>비트 시프트의 개념이 생소할 수 있지만 결국, 오른쪽 비트 시프트 연산자는 **2로 나눈 효과**를, 
>왼쪽 비트 시프트 연산자는 **2를 곱한 효과**를 낸다. 

<br>

다음은 비트 시프트 연산을 사용한 간단한 예시이다.

**<오른쪽 비트시프트 연산>**
```C
#include <stdio.h>

int main() {
    int num = 16; // 00010000 (2진수)
	
    printf("오른쪽 시프트 이전: %d (2진수: %d)\n", num, num);
    
    num = num >> 1;
	
    printf("오른쪽 시프트 이후: %d (2진수: %d)\n", num, num);

    return 0;
}

```
**\<Result>**
```C
오른쪽 시프트 이전: 16 (2진수: 10000)
오른쪽 시프트 이후: 8 (2진수: 1000)

```

<br>

**<왼쪽 비트시프트 연산>**
```C
#include <stdio.h>

int main() {
    int num = 4; // 00000100 (2진수)
	
    printf("왼쪽 시프트 이전: %d (2진수: %d)\n", num, num);
    
    num = num << 2;
	
    printf("왼쪽 시프트 이후: %d (2진수: %d)\n", num, num);
	
    return 0;
}
```
**\<Result>**
```C
왼쪽 시프트 이전: 4 (2진수: 100)
왼쪽 시프트 이후: 16 (2진수: 10000)
```


<br>

###### 참고문서
- [[조건 연산자]]
- [[관계 연산자]]
- [[관계 연산자]]
- [[산술 연산자]]

